<?xml version="1.0" encoding="utf-8" ?>
<configuration>

  <configSections>
    <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" />
    <section name="hibernate-configuration" type="NHibernate.Cfg.ConfigurationSectionHandler, NHibernate" />
    <section name="ThreadPoolSection" type="Forge.Threading.ConfigSection.ThreadPoolSection, Forge.Base, Culture=neutral, PublicKeyToken=97960309cfe8d317" allowLocation="true" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="false" requirePermission="true" />
    <section name="TerraGrafSection" type="Forge.Net.TerraGraf.ConfigSection.TerraGrafSection, Forge.Net.TerraGraf, Culture=neutral, PublicKeyToken=97960309cfe8d317" allowLocation="true" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="true" requirePermission="true" />
    <section name="RemotingSection" type="Forge.Net.Remoting.ConfigSection.RemotingSection, Forge.Net.Remoting, Culture=neutral, PublicKeyToken=97960309cfe8d317" allowLocation="true" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="false" requirePermission="true" />
    <section name="EverlightSection" type="Forge.Everlight.ConfigSection.EverlightSection, Forge.Everlight, Culture=neutral, PublicKeyToken=97960309cfe8d317" allowLocation="true" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="true" requirePermission="true" />
    <section name="StorageSection" type="Forge.Persistence.StorageProviders.ConfigSection.StorageSection, Forge.Base, Culture=neutral, PublicKeyToken=97960309cfe8d317" allowLocation="true" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="false" requirePermission="true" />
  </configSections>


  <appSettings>
    <add key="log4net.Internal.Debug" value="false" />
    <add key="ApplicationID" value="RS2" />
  </appSettings>

  <!--<runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      -->
  <!-- NHibernate requires this entry -->
  <!--
      <qualifyAssembly partialName="System.Data.SqlServerCe" fullName="System.Data.SqlServerCe, Version=4.0.0.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91"/>
    </assemblyBinding>
  </runtime>-->

  <!--DefaultLocalDB-->

  <connectionStrings>
    <add name="EverlightTest1DB" providerName="System.Data.SqlClient" connectionString="Data Source=.\SQLEXPRESS2008; Initial Catalog=EverlightTest1; User Id=EverlightTest1; Password=EverlightTest1"/>
    <!--<add name="EverlightTest2DB" providerName="System.Data.SqlClient" connectionString="Data Source=.\SQLEXPRESS2008; Initial Catalog=EverlightTest2; User Id=EverlightTest2; Password=EverlightTest2"/>-->
    <add name="NHibernateStorageProvider" providerName="System.Data.SqlClient" connectionString="Data Source=.\SQLEXPRESS2008; Initial Catalog=NHibernateStorageProvider; User Id=NHibernateStorageProvider; Password=NHibernateStorageProvider001"/>
  </connectionStrings>

  <hibernate-configuration xmlns="urn:nhibernate-configuration-2.2">
    <session-factory>
    </session-factory>
  </hibernate-configuration>




  <EverlightSection>
    <CategoryPropertyItems>

      <add id="Settings">
        <PropertyItems>

          <!-- Alapértelmezetten használt rendszer -->
          <add id="DefaultSystemConfigId" entryValue="System1" />

          <!-- Alapértelmezett adatbáziskapcsolat azoknál a rendszereknél, ahol a DB kapcsolódás nincs külön definiálva -->
          <add id="DefaultDataSourceConfigId" entryValue="EverlightTest1" />

          <!-- DB Scheme auto control, default is true. Order of schema handling: validate, update, create -->
          <add id="AutoControlDatabaseSchema" entryValue="true" />

          <!-- Teljes rendszer vagyis az összes domain újraszinkronizálása a szerverrel. -->
          <add id="ResynchronizeEntireSystem" entryValue="false" />

          <!-- Ha egy ismert Device nem jelentkezik be a megadott időn belül, a rendszer törli a hozzá tartozó információkat.
                    Ha az eszköz a megadott időn túl ismét bejelentkezik, ismételten szinkronizálnia kellesz.
                    Alapértelmezett érték 86400 másodperc, azaz 24 óra. -->
          <add id="DeviceInactivityTimeInSeconds" entryValue="86400" />

          <!-- Maintenance Manager feladatvégrehajtás késleltetése -->
          <add id="MaintenanceManagerExecutionDelayMS" entryValue="5000" />

          <!-- Tároló mappa az Everlight számára. Ha üresen hagyjuk, automatikus. -->
          <add id="StorageFolder" entryValue="" />

          <!-- Ha a tároló mappa neve automatikusan generálódik, a rendszer hozzáadja-e az AppDomain nevét a mappához. -->
          <add id="AppendDomainNameIntoStorageFolder" entryValue="false" />

          <!-- A Communication Manager tömörítse az adatábázisba mententő adatokat. Kisebb méretű adatbázist eredményezhet. Az alkalmazás legelső indítása előtt szabad beállítani! -->
          <add id="CompressPersistentContent" entryValue="false" />

          <!-- Távoli adminisztráció engedélyezése -->
          <add id="EnableRemoteAdministration" entryValue="true" />

          <!-- Távoli adminisztrációs hozzáférés által használt csatorna azonosítója -->
          <add id="RemoteAdministrationChannelId" entryValue="ChannelReceiveConnection" />

        </PropertyItems>
      </add>

      <add id="Systems">
        <PropertyItems>

          <add id="SystemRelayServer21">
            <PropertyItems>

              <!-- Rendszer azonosítója -->
              <add id="SystemId" entryValue="21" />

              <!-- Rendszer által használt adatbáziskapcsolat -->
              <add id="DataSourceConfigId" entryValue="EverlightTest1" />
              <!--DefaultLocalDB-->

              <!-- Kliens szinkronizáció módja
                    ServerWin - Mentés során a szerver felhasználja az automatikusan hozzáadott verzió ellenőrző adatokat.
                    ClientWin - Mentés során az automatikusan hozzáadott verzióellenőrzések nem kerülnek felhasználásra, így a mentés felülírhat már meglévő adatokat.
              -->
              <add id="DefaultSynchronizationMode" entryValue="ServerWin" />

              <!-- Commit alapértelmezett viselkedése
                    Auto - Automatikusan választja a rendszer a Sync vagy Async commit módot. Controllernél async, normál kliensnél a sync javasolt.
                    Synchronized - A UnitOfWork-öt azonnal szinkronizálja a szerverrel és az adatbázisba is commit-ol.
                                    A commit metódus a végrehajtás idejére blokkolódik. Ha a szinkronizálás vagy a commit sikertelen,
                                    kivétel dobódik.
                    Asynchronized - Átadja a UnitOfWork-ot a SynchronizationManager-nek szinkronizálásra, de nem várja meg annak lefutását.
                                    Ezután azonnal commit-ol az adatbázisba.
              -->
              <add id="DefaultCommitMode" entryValue="Auto" />

              <!--
                  Second level cache használata
                  Get - The session may read items from the cache, but will not add items, except to invalidate items when updates occur
                  Ignore - The session will never interact with the cache, except to invalidate cache items when updates occur
                  Normal - The session may read items from the cache, and add items to the cache
                  Put - The session will never read items from the cache, but will add items to the cache as it reads them from the database
                  Refresh - The session will never read items from the cache, but will add items to the cache as it reads them from the database. In this mode, the effect of hibernate.cache.use_minimal_puts is bypassed, in order to force a cache refresh
              -->
              <add id="DefaultCacheMode" entryValue="Normal" />

              <!-- Rendszer tartomány teljes újraszinkronizációja a masterszerverrel. HighCommand Master Server-en nincs hatása az opciónak. -->
              <add id="FullResynchronization" entryValue="false" />

              <!-- Eszköz működési módja:
                  HighCommandMasterServer - Legfelsőbb szintű master szerver, felette nem áll senki.
                  RelayServer - Szerver, aminek van egy master szervere.
                  Terminal - Kliens, aki nem fogad más kliensektől bejövő UnitOfWork-öt.
                  Standalone - Önálló kliens, nincs sem szervere, sem kliensei.
              -->
              <add id="DeviceType" entryValue="RelayServer" />

              <!-- Domain Manager persistent tárolóinak maximális mérete (PersistentDictionary és PersistentList cache size)
                  Nagyobb érték jelentősen növeli a teljesítményt, de több memóriát követel meg.
                  Értéke 1 és Integer.MAX_VALUE tartományba eshet. Ha nem adunk meg semmit, akkor a default Integer.MAX_VALUE.
              -->
              <add id="DomainManagerPersistentCacheSize" entryValue="default" />

              <!-- A Domain Manager tömörítse az adatábázisba mententő adatokat. Kisebb méretű adatbázist eredményezhet. Az alkalmazás legelső indítása előtt szabad beállítani! -->
              <add id="DomainManagerCompressPersistentContent" entryValue="false" />

              <!-- A rendszer automatikus karbantartási feladatot indít, ha a Finally Commit-os UoW-ök száma eléri a határt. Ha az érték kisebb mint egy, akkor ki van kapcsolva a funkció. -->
              <add id="AutoDatabaseSnapshotCreationAtCountOfUoW" entryValue="100" />

              <!-- Database snapshot-ra vonatkozó beállítások -->
              <add id="DatabaseSnapshotSettings">
                <PropertyItems>

                  <!-- A háttértárolón a rendszer domainhez biztonsági másolatként megtartott databaseSnapshot fájlok száma -->
                  <add id="MaxBackupNumber" entryValue="5" />

                  <!-- A database snapshot-ot tárolja a memóriában -->
                  <add id="KeepDatabaseSnapshotInMemory" entryValue="true" />

                </PropertyItems>
              </add>

              <add id="CommunicationSettings">
                <PropertyItems>

                  <!-- Bejövő klienseket fogadó remoting csatorna azonosítója. Ha nem adunk meg semmit, akkor automatikus. -->
                  <add id="RemotingServerChannel" entryValue="ChannelReceiveConnection" />

                  <!-- Csatlakozáshoz használható remoting csatorna azonosítója. Ha nem adunk meg semmit, akkor automatikus. -->
                  <add id="RemotingClientChannel" entryValue="ChannelConnectToMaster" />

                  <!-- Eszköz prioritása a kapcsolati fában.
                      HCMS mindig zero, rendszer felülírja!
                      RelayServer és Terminal mindig 1-től kezdődik. Alapértelmezett érték: 1.
                      Ez az érték segít failover alkalmazása esetén a klienseknek kiválasztani a felsőbbszintű kiszolgálót.
                      Alacsonyabb rangú kiszolgálóhoz nem kapcsolódik ez a kliens.
                  -->
                  <add id="DeviceNodePriority" entryValue="1" />

                  <!-- Definiálom, hogy ez a rendszer milyen típusú kiszolgálót részesít előnyben
                      kiszolgáló keresésekor. A megadott típusú kiszolgálót keresi és ahhoz próbál csatlakozni.
                      Értékek:
                      None - Nincs értelmezve (HCMS, SA)
                      HigherPriority - Magasabb prioritásút keres először
                      EqualPriority - Vele azonos prioritásút keres először
                  -->
                  <add id="SelectionPriority" entryValue="HigherPriority" />
                  <!--EqualPriority-->

                  <!-- Definiálom, hogy ez a rendszer milyen típusú kiszolgálókhoz kapcsolódhat 
                      Értékek:
                      None - Nincs értelmezve (HCMS, SA)
                      HigherPriority - Csak magasabb prioritású eszközhöz kapcsolódhat
                      EqualPriority - Csak azonos prioritású eszközhöz kapcsolódhat
                      Both - Magasabb és azonos prioritású eszközök is engedélyezettel
                  -->
                  <add id="ConnectionAbility" entryValue="HigherPriority" />
                  <!--EqualPriority-->

                  <!-- Ez az érték azt mondja meg, hogy új kiszolgáló választás esetén,
                      ha magasabb prioritásúak között keres, maximum hány prioritási értékkel magasabb
                      eszközt választhat masternek. Default: Int32.MaxValue, azaz bármelyik felsőbbszintű kiszolgálót választhatja.
                      A keresés szekvencviális, azaz a saját prioritási szintjétől kezdve halad felfelé.
                  -->
                  <add id="MaxStepThroughPriority" entryValue="2" />

                  <!-- A megadott ideig keresi vagy vár az eredeti kiszolgálóra. Ezt követően kezd csak a rendszer másik kiszolgálót keresgélni. -->
                  <add id="HostSearchWaitTimeoutInMS" entryValue="10000" />

                  <!-- Megadja, hogy egy szavazás során meddig várunk a potenciális jelöltek jelentkezésére, mielőtt az adatgyűjtési elindul. -->
                  <add id="ElectionNominationWaitTimeInMS" entryValue="10000" />

                  <!-- Megadja, hogy egy szavazás során meddig várunk a jelöltek adatainak beérkezésére, mielőtt a választási folyamat elindul. -->
                  <add id="ElectionMetaDataWaitTimeInMS" entryValue="10000" />

                  <!-- Azoknak a moduloknak a listája, amelyek segítenek eldönteni host kiválasztáskor, hogy az aktuális alkalmazás jelöltetheti
                      magát host-nak.
                      Ennek a lényege, hogy üzleti követelmények is beleszólhatnak a folyamatba, ezért a döntéshez külső üzleti döntési modulokat lehet csatolni.
                  -->
                  <add id="HostDecisionModules">
                    <PropertyItems>

                    </PropertyItems>
                  </add>

                </PropertyItems>
              </add>

            </PropertyItems>
          </add>

          <add id="SystemRelayServer22">
            <PropertyItems>

              <!-- Rendszer azonosítója -->
              <add id="SystemId" entryValue="22" />

              <!-- Rendszer által használt adatbáziskapcsolat -->
              <add id="DataSourceConfigId" entryValue="EverlightTest1" />
              <!--DefaultLocalDB-->

              <!-- Kliens szinkronizáció módja
                    ServerWin - Mentés során a szerver felhasználja az automatikusan hozzáadott verzió ellenőrző adatokat.
                    ClientWin - Mentés során az automatikusan hozzáadott verzióellenőrzések nem kerülnek felhasználásra, így a mentés felülírhat már meglévő adatokat.
              -->
              <add id="DefaultSynchronizationMode" entryValue="ServerWin" />

              <!-- Commit alapértelmezett viselkedése
                    Auto - Automatikusan választja a rendszer a Sync vagy Async commit módot. Controllernél async, normál kliensnél a sync javasolt.
                    Synchronized - A UnitOfWork-öt azonnal szinkronizálja a szerverrel és az adatbázisba is commit-ol.
                                    A commit metódus a végrehajtás idejére blokkolódik. Ha a szinkronizálás vagy a commit sikertelen,
                                    kivétel dobódik.
                    Asynchronized - Átadja a UnitOfWork-ot a SynchronizationManager-nek szinkronizálásra, de nem várja meg annak lefutását.
                                    Ezután azonnal commit-ol az adatbázisba.
              -->
              <add id="DefaultCommitMode" entryValue="Auto" />

              <!--
                  Second level cache használata
                  Get - The session may read items from the cache, but will not add items, except to invalidate items when updates occur
                  Ignore - The session will never interact with the cache, except to invalidate cache items when updates occur
                  Normal - The session may read items from the cache, and add items to the cache
                  Put - The session will never read items from the cache, but will add items to the cache as it reads them from the database
                  Refresh - The session will never read items from the cache, but will add items to the cache as it reads them from the database. In this mode, the effect of hibernate.cache.use_minimal_puts is bypassed, in order to force a cache refresh
              -->
              <add id="DefaultCacheMode" entryValue="Normal" />

              <!-- Rendszer tartomány teljes újraszinkronizációja a masterszerverrel. HighCommand Master Server-en nincs hatása az opciónak. -->
              <add id="FullResynchronization" entryValue="false" />

              <!-- Eszköz működési módja:
                  HighCommandMasterServer - Legfelsőbb szintű master szerver, felette nem áll senki.
                  RelayServer - Szerver, aminek van egy master szervere.
                  Terminal - Kliens, aki nem fogad más kliensektől bejövő UnitOfWork-öt.
                  Standalone - Önálló kliens, nincs sem szervere, sem kliensei.
              -->
              <add id="DeviceType" entryValue="RelayServer" />

              <!-- Domain Manager persistent tárolóinak maximális mérete (PersistentDictionary és PersistentList cache size)
                  Nagyobb érték jelentősen növeli a teljesítményt, de több memóriát követel meg.
                  Értéke 1 és Integer.MAX_VALUE tartományba eshet. Ha nem adunk meg semmit, akkor a default Integer.MAX_VALUE.
              -->
              <add id="DomainManagerPersistentCacheSize" entryValue="default" />

              <!-- A Domain Manager tömörítse az adatábázisba mententő adatokat. Kisebb méretű adatbázist eredményezhet. Az alkalmazás legelső indítása előtt szabad beállítani! -->
              <add id="DomainManagerCompressPersistentContent" entryValue="false" />

              <!-- A rendszer automatikus karbantartási feladatot indít, ha a Finally Commit-os UoW-ök száma eléri a határt. Ha az érték kisebb mint egy, akkor ki van kapcsolva a funkció. -->
              <add id="AutoDatabaseSnapshotCreationAtCountOfUoW" entryValue="100" />

              <!-- Database snapshot-ra vonatkozó beállítások -->
              <add id="DatabaseSnapshotSettings">
                <PropertyItems>

                  <!-- A háttértárolón a rendszer domainhez biztonsági másolatként megtartott databaseSnapshot fájlok száma -->
                  <add id="MaxBackupNumber" entryValue="5" />

                  <!-- A database snapshot-ot tárolja a memóriában -->
                  <add id="KeepDatabaseSnapshotInMemory" entryValue="true" />

                </PropertyItems>
              </add>

              <add id="CommunicationSettings">
                <PropertyItems>

                  <!-- Bejövő klienseket fogadó remoting csatorna azonosítója. Ha nem adunk meg semmit, akkor automatikus. -->
                  <add id="RemotingServerChannel" entryValue="ChannelReceiveConnection" />

                  <!-- Csatlakozáshoz használható remoting csatorna azonosítója. Ha nem adunk meg semmit, akkor automatikus. -->
                  <add id="RemotingClientChannel" entryValue="ChannelConnectToMaster" />

                  <!-- Eszköz prioritása a kapcsolati fában.
                      HCMS mindig zero, rendszer felülírja!
                      RelayServer és Terminal mindig 1-től kezdődik. Alapértelmezett érték: 1.
                      Ez az érték segít failover alkalmazása esetén a klienseknek kiválasztani a felsőbbszintű kiszolgálót.
                      Alacsonyabb rangú kiszolgálóhoz nem kapcsolódik ez a kliens.
                  -->
                  <add id="DeviceNodePriority" entryValue="1" />

                  <!-- Definiálom, hogy ez a rendszer milyen típusú kiszolgálót részesít előnyben
                      kiszolgáló keresésekor. A megadott típusú kiszolgálót keresi és ahhoz próbál csatlakozni.
                      Értékek:
                      None - Nincs értelmezve (HCMS, SA)
                      HigherPriority - Magasabb prioritásút keres először
                      EqualPriority - Vele azonos prioritásút keres először
                  -->
                  <add id="SelectionPriority" entryValue="EqualPriority" />
                  <!--EqualPriority-->

                  <!-- Definiálom, hogy ez a rendszer milyen típusú kiszolgálókhoz kapcsolódhat 
                      Értékek:
                      None - Nincs értelmezve (HCMS, SA)
                      HigherPriority - Csak magasabb prioritású eszközhöz kapcsolódhat
                      EqualPriority - Csak azonos prioritású eszközhöz kapcsolódhat
                      Both - Magasabb és azonos prioritású eszközök is engedélyezettel
                  -->
                  <add id="ConnectionAbility" entryValue="EqualPriority" />
                  <!--EqualPriority-->

                  <!-- Ez az érték azt mondja meg, hogy új kiszolgáló választás esetén,
                      ha magasabb prioritásúak között keres, maximum hány prioritási értékkel magasabb
                      eszközt választhat masternek. Default: Int32.MaxValue, azaz bármelyik felsőbbszintű kiszolgálót választhatja.
                      A keresés szekvencviális, azaz a saját prioritási szintjétől kezdve halad felfelé.
                  -->
                  <add id="MaxStepThroughPriority" entryValue="1" />

                  <!-- A megadott ideig keresi vagy vár az eredeti kiszolgálóra. Ezt követően kezd csak a rendszer másik kiszolgálót keresgélni. -->
                  <add id="HostSearchWaitTimeoutInMS" entryValue="10000" />

                  <!-- Megadja, hogy egy szavazás során meddig várunk a potenciális jelöltek jelentkezésére, mielőtt az adatgyűjtési elindul. -->
                  <add id="ElectionNominationWaitTimeInMS" entryValue="10000" />

                  <!-- Megadja, hogy egy szavazás során meddig várunk a jelöltek adatainak beérkezésére, mielőtt a választási folyamat elindul. -->
                  <add id="ElectionMetaDataWaitTimeInMS" entryValue="10000" />

                  <!-- Azoknak a moduloknak a listája, amelyek segítenek eldönteni host kiválasztáskor, hogy az aktuális alkalmazás jelöltetheti
                      magát host-nak.
                      Ennek a lényege, hogy üzleti követelmények is beleszólhatnak a folyamatba, ezért a döntéshez külső üzleti döntési modulokat lehet csatolni.
                  -->
                  <add id="HostDecisionModules">
                    <PropertyItems>

                    </PropertyItems>
                  </add>

                </PropertyItems>
              </add>

            </PropertyItems>
          </add>
          
        </PropertyItems>
      </add>

      <!-- Adatbázis kapcsolatok definíciói -->
      <add id="DataSources">
        <PropertyItems>

          <add id="EverlightTest1">
            <PropertyItems>

              <!-- Az NHibernate melyik assembly-ben keresse az entitásokat -->
              <!--Ide több assembly-t fogok megadni-->
              <add id="ModelAssemblies">
                <PropertyItems>
                  <add id="Testing.TerraGraf.Entities" />
                  <add id="Forge.Testing.Everlight.Entities" />
                </PropertyItems>
              </add>

              <!-- Represents the database manager for this type of database configuration -->
              <add id="DatabaseManager" entryValue="" />

              <!-- NHibernate paraméterek -->
              <add id="Settings">
                <PropertyItems>
                  <!--<add id="dialect" entryValue="NHibernate.Dialect.MsSql2008Dialect" />-->
                  <add id="dialect" entryValue="Forge.DatabaseManagement.SqlServer2008.MsSql2008Dialect, Forge.DatabaseManagement.SqlServer2008" />
                  <add id="connection.provider" entryValue="NHibernate.Connection.DriverConnectionProvider" />
                  <add id="connection.driver_class" entryValue="NHibernate.Driver.Sql2008ClientDriver" />
                  <!-- Connection Strings-ben definiált kapcsolat azonosítóneve -->
                  <add id="connection.connection_string_name" entryValue="EverlightTest1DB" />
                  <add id="connection.isolation" entryValue="ReadCommitted" />
                  <add id="cache.use_query_cache" entryValue="false" />
                  <add id="cache.use_second_level_cache" entryValue="false" />
                  <add id="adonet.batch_size" entryValue="10" />
                  <add id="show_sql" entryValue="false" />
                  <add id="command_timeout" entryValue="60" />
                  <add id="query.substitutions" entryValue="true 1, false 0, yes 'Y', no 'N'" />
                  <add id="max_fetch_depth" entryValue="3" />
                  <add id="use_reflection_optimizer" entryValue="true" />
                  <!--add id="prepare_sql" entryValue="true" /-->
                </PropertyItems>
              </add>

            </PropertyItems>
          </add>
          
        </PropertyItems>
      </add>


        </CategoryPropertyItems>
      </EverlightSection>
        

  <RemotingSection>
    <CategoryPropertyItems>

      <add id="Settings">
        <PropertyItems>
          <!-- Csatornák automatikus betöltése indításkor -->
          <add id="AutomaticallyLoadChannels" entryValue="true" />
        </PropertyItems>
      </add>

      <add id="Services">
        <PropertyItems>



        </PropertyItems>
      </add>

      <add id="Clients">
        <PropertyItems>



        </PropertyItems>
      </add>

      <add id="Channels">
        <PropertyItems>

          <add id="ChannelReceiveConnection" entryValue="Forge.Net.Remoting.Channels.TCPChannel, Forge.Net.Remoting">
            <PropertyItems>

              <add id="BaseAddresses">
                <PropertyItems>
                  <add id="0" entryValue="127.0.0.1:57000" />
                </PropertyItems>
              </add>

              <add id="NetworkFactoryType" entryValue="Forge.Net.TerraGraf.TerraGrafNetworkFactory, Forge.Net.TerraGraf" />

              <add id="ServerStreamFactoryType" entryValue="Forge.Net.Synapse.NetworkFactory.SslServerStreamFactory, Forge.Net.Synapse">
                <PropertyItems>

                  <!-- Socket ReceiveBufferSize -->
                  <add id="ReceiveBufferSize" entryValue="8192" />

                  <!-- Socket SendBufferSize -->
                  <add id="SendBufferSize" entryValue="8192" />

                  <!-- Store/File -->
                  <add id="CertificateSource" entryValue="Store" />

                  <!-- Use this settings when you get certificate from your computer store -->
                  <!-- Name of the certificate store. Values are System.Security.Cryptography.X509Certificates.StoreName enum values. Default is My. -->
                  <add id="StoreName" entryValue="My" />
                  <!-- Scope of the certificate store. Values are System.Security.Cryptography.X509Certificates.StoreLocation enum values. Default is CurrentUser. -->
                  <add id="StoreLocation" entryValue="CurrentUser" />
                  <!-- The subject of the certificate to find. Required. -->
                  <add id="Subject" entryValue="CN=ForgeNET" />

                  <!-- Use this settings when you get certificate from a local file -->
                  <add id="CertificateFile" entryValue="ForgeNET.pfx" />
                  <!-- Password for the certificate -->
                  <add id="Password" entryValue="" />

                </PropertyItems>
              </add>

              <add id="ClientStreamFactoryType" entryValue="Forge.Net.Synapse.NetworkFactory.SslClientStreamFactory, Forge.Net.Synapse">
                <PropertyItems>

                  <!-- Socket ReceiveBufferSize -->
                  <add id="ReceiveBufferSize" entryValue="8192" />

                  <!-- Socket SendBufferSize -->
                  <add id="SendBufferSize" entryValue="8192" />

                  <!-- Same as the subject name on the server certificate -->
                  <add id="ServerNameOnCertificate" entryValue="ForgeNET" />

                  <!-- Skip the errors of the SSL Policy and continue. This means lower security, but ideal for development. Default is false. -->
                  <add id="SkipSslPolicyErrors" entryValue="true" />

                </PropertyItems>
              </add>

              <add id="DefaultErrorResponseTimeout" entryValue="60000" />
              <add id="MaxSendMessageSize" entryValue="32768" />
              <add id="MaxReceiveMessageSize" entryValue="32768" />
              <add id="MaxSendStreamSize" entryValue="268435456" />
              <add id="MaxReceiveStreamSize" entryValue="268435456" />
              <add id="TempStreamStorageFolder" entryValue="StorageFolder/TempStreams" />

              <add id="SendSinks">
                <PropertyItems>

                  <add id="0" entryValue="Forge.Net.Remoting.Sinks.BinarySerializerMessageSink, Forge.Net.Remoting">
                    <PropertyItems>
                      <add id="CompressData" entryValue="true" />
                      <add id="CompressDataOverSize" entryValue="1024" />
                    </PropertyItems>
                  </add>

                </PropertyItems>
              </add>

              <add id="ReceiveSinks">
                <PropertyItems>

                  <add id="0" entryValue="Forge.Net.Remoting.Sinks.BinarySerializerMessageSink, Forge.Net.Remoting">
                    <PropertyItems>
                      <add id="CompressData" entryValue="true" />
                      <add id="CompressDataOverSize" entryValue="1024" />
                    </PropertyItems>
                  </add>

                </PropertyItems>
              </add>

            </PropertyItems>
          </add>

          <add id="ChannelConnectToMaster" entryValue="Forge.Net.Remoting.Channels.TCPChannel, Forge.Net.Remoting">
            <PropertyItems>
              <add id="RemoteAddress" entryValue="127.0.0.1:57000" />

              <add id="NetworkFactoryType" entryValue="Forge.Net.TerraGraf.TerraGrafNetworkFactory, Forge.Net.TerraGraf" />

              <add id="ServerStreamFactoryType" entryValue="Forge.Net.Synapse.NetworkFactory.SslServerStreamFactory, Forge.Net.Synapse">
                <PropertyItems>

                  <!-- Socket ReceiveBufferSize -->
                  <add id="ReceiveBufferSize" entryValue="8192" />

                  <!-- Socket SendBufferSize -->
                  <add id="SendBufferSize" entryValue="8192" />

                  <!-- Store/File -->
                  <add id="CertificateSource" entryValue="Store" />

                  <!-- Use this settings when you get certificate from your computer store -->
                  <!-- Name of the certificate store. Values are System.Security.Cryptography.X509Certificates.StoreName enum values. Default is My. -->
                  <add id="StoreName" entryValue="My" />
                  <!-- Scope of the certificate store. Values are System.Security.Cryptography.X509Certificates.StoreLocation enum values. Default is CurrentUser. -->
                  <add id="StoreLocation" entryValue="CurrentUser" />
                  <!-- The subject of the certificate to find. Required. -->
                  <add id="Subject" entryValue="CN=ForgeNET" />

                  <!-- Use this settings when you get certificate from a local file -->
                  <add id="CertificateFile" entryValue="ForgeNET.pfx" />
                  <!-- Password for the certificate -->
                  <add id="Password" entryValue="" />

                </PropertyItems>
              </add>

              <add id="ClientStreamFactoryType" entryValue="Forge.Net.Synapse.NetworkFactory.SslClientStreamFactory, Forge.Net.Synapse">
                <PropertyItems>

                  <!-- Socket ReceiveBufferSize -->
                  <add id="ReceiveBufferSize" entryValue="8192" />

                  <!-- Socket SendBufferSize -->
                  <add id="SendBufferSize" entryValue="8192" />

                  <!-- Same as the subject name on the server certificate -->
                  <add id="ServerNameOnCertificate" entryValue="ForgeNET" />

                  <!-- Skip the errors of the SSL Policy and continue. This means lower security, but ideal for development. Default is false. -->
                  <add id="SkipSslPolicyErrors" entryValue="true" />

                </PropertyItems>
              </add>

              <add id="DefaultErrorResponseTimeout" entryValue="60000" />
              <add id="MaxSendMessageSize" entryValue="32768" />
              <add id="MaxReceiveMessageSize" entryValue="32768" />
              <add id="MaxSendStreamSize" entryValue="268435456" />
              <add id="MaxReceiveStreamSize" entryValue="268435456" />
              <add id="TempStreamStorageFolder" entryValue="StorageFolder/TempStreams" />

              <add id="SendSinks">
                <PropertyItems>

                  <add id="0" entryValue="Forge.Net.Remoting.Sinks.BinarySerializerMessageSink, Forge.Net.Remoting">
                    <PropertyItems>
                      <add id="CompressData" entryValue="true" />
                      <add id="CompressDataOverSize" entryValue="1024" />
                    </PropertyItems>
                  </add>

                </PropertyItems>
              </add>

              <add id="ReceiveSinks">
                <PropertyItems>

                  <add id="0" entryValue="Forge.Net.Remoting.Sinks.BinarySerializerMessageSink, Forge.Net.Remoting">
                    <PropertyItems>
                      <add id="CompressData" entryValue="true" />
                      <add id="CompressDataOverSize" entryValue="1024" />
                    </PropertyItems>
                  </add>

                </PropertyItems>
              </add>

            </PropertyItems>
          </add>

        </PropertyItems>
      </add>

    </CategoryPropertyItems>
  </RemotingSection>

  <TerraGrafSection>
    <CategoryPropertyItems>

      <add id="Settings">
        <PropertyItems>

          <!-- Ha ez az opció aktív, akkor ez a kliens letagad minden kapcsolatot, még a saját Network Context-jáben lévőket is -->
          <!-- Ennek az lesz a következménye, hogy ezt a kliens nem fogják átmenő forgalommal terhelni, ellenben a hálózat -->
          <!-- áteresztő képessége és átjárhatósága csökken. -->
          <add id="BlackHole" entryValue="false" />

          <!-- Csatlakozás alapértelmezett érték miliszekundumban. 0-tól nagyobb szám -->
          <add id="DefaultConnectionTimeoutInMS" entryValue="120000" />

          <!-- Több párhuzamos fizikai kapcsolat engedélyezése egy hálózati résztvevővel -->
          <add id="EnableMultipleConnectionWithNetworkPeers" entryValue="true" />

          <!-- Agresszív kapcsolatépítés a hálózati résztvevőkkel -->
          <add id="EnableAgressiveConnectionEstablishment" entryValue="true" />

          <!-- Párhuzamos kapcsolatépíthetőség esetén, a kapcsolatok maximális száma -->
          <add id="MaxConnectionsWithNetworkPeers" entryValue="2" />

          <!-- Felülírhatjuk, hogy a rendszer hányszor engedjen továbbítani egy keringő, gazdátlan üzenetet -->
          <add id="MaxMessagePassageNumber" entryValue="3" />

          <!-- IPV6 protokol engedélyezése -->
          <add id="EnableIPV6" entryValue="false" />

          <!-- Listener socket queue-jában várakozó bejövő, de még nem fogadott kapcsolatok timeout értéke. Egy bejövő kapcsolat ennyi idő után timeoutol el, ha nem fogadom. -->
          <add id="DefaultSocketAcceptTimeWaitInMS" entryValue="60000" />

          <!-- Listener socket queue maximális mérete. Maximum az itt beállított mennyiségű bejövő és feldolgozásra váró kapcsolat lehet a queue-ban. -->
          <add id="DefaultSocketBacklogSize" entryValue="256" />

          <!-- Alapértelmezett keep alive time érték az alacsony szintű socket-eknek -->
          <add id="DefaultLowLevelSocketKeepAliveTime" entryValue="60000" />

          <!-- Alapértelmezett keep alive time interval érték az alacsony szintű socket-eknek -->
          <add id="DefaultLowLevelSocketKeepAliveTimeInterval" entryValue="1000" />

          <!-- Alapértelmezett fogadó buffer mérete az alacsony szintű socket-eknek -->
          <add id="DefaultLowLevelSocketReceiveBufferSize" entryValue="8192" />

          <!-- Alapértelmezett küldő buffer mérete az alacsony szintű socket-eknek -->
          <add id="DefaultLowLevelSocketSendBufferSize" entryValue="8192" />

          <!-- Alapértelmezett fogadó buffer mérete a magas szintű socket-eknek -->
          <add id="DefaultReceiveBufferSize" entryValue="8192" />

          <!-- Alapértelmezett küldő buffer mérete a magas szintű socket-eknek -->
          <add id="DefaultSendBufferSize" entryValue="8192" />

          <!-- Párhuzamos csatlakozási kérések maximális száma a magas szintű socketeken. -->
          <add id="DefaultConcurrentSocketConnectionAttempts" entryValue="10" />

          <!-- Alapértelmezett timeout érték az alacsony szintű és a magas szintű socket-eknek, ami azt mondja meg, hogy mennyi ideig vár egy blokkolt socket bejövő adatra -->
          <add id="DefaultReceiveTimeoutInMS" entryValue="-1" />

          <!-- Alapértelmezett timeout érték az alacsony szintű és a magas szintű socket-eknek, ami azt mondja meg, hogy mennyi ideig vár egy blokkolt socket az adat elküldésére -->
          <add id="DefaultSendTimeoutInMS" entryValue="-1" />

          <!-- Add application to the Windows Firewall -->
          <add id="AddWindowsFirewallException" entryValue="true" />

        </PropertyItems>
      </add>

      <add id="NetworkPeering">
        <PropertyItems>

          <!-- NAT gateway-ek listája. A routeren beállított DynDNS és port forward szabályokat -->
          <!-- ki lehet publikálni. Ekkor a külső hálózatokból érkező peer-ek is be tudnak kapcsolódni -->
          <add id="NAT_Gateways">
            <PropertyItems>
              <!--add id="0" entryValue="jzo.ddns.net:17625" /-->
            </PropertyItems>
          </add>

          <!-- TCP szerverek listája -->
          <add id="TCPServers">
            <PropertyItems>
              <!-- Megadhatjuk, hogy automatikusan válasszon portot és interface-t -->
              <add id="Auto" entryValue="true">
                <PropertyItems>
                  <!-- Ha az automatika tiltva van, akkor itt kézzel megadhatjuk, hogy mely interface-eken és portokon figyeljen -->
                  <add id="0" entryValue="0.0.0.0:59700" />
                </PropertyItems>
              </add>
            </PropertyItems>
          </add>

          <!-- Megadhatunk fix listát is, hogy hová próbálkozzon csatlakozni -->
          <add id="TCP_Connections">
            <PropertyItems>

              <!--add id="0" entryValue="127.0.0.1:59700">
                <PropertyItems>
                  <add id="ReconnectOnFailure" entryValue="true" />
                  <add id="DelayBetweenAttempsInMS" entryValue="10000" />
                  <add id="ConnectionTimeout" entryValue="-1" />
                </PropertyItems>
              </add-->

            </PropertyItems>
          </add>

          <!-- Engedélyezzük az UDP felderítést -->
          <add id="UDP_Detection" entryValue="false">
            <PropertyItems>

              <!-- A felsorolt portok közül, az első szabad portra, amit talál ráül és figyel -->
              <add id="Broadcast_Listening_Ports">
                <PropertyItems>
                  <add id="0" entryValue="58600" />
                  <add id="1" entryValue="58601" />
                  <add id="2" entryValue="58602" />
                </PropertyItems>
              </add>

              <!-- A peer-ek keresésekor az alábbi portokra küld ki üzenetet a broadcast címen -->
              <add id="Broadcast_Target_Ports">
                <PropertyItems>
                  <add id="0" entryValue="58600" />
                  <add id="1" entryValue="58601" />
                  <add id="2" entryValue="58602" />
                </PropertyItems>
              </add>

            </PropertyItems>
          </add>

          <!-- Engedélyezzük az NATUPnP szolgáltatást -->
          <add id="NETUPnP" entryValue="true">
            <PropertyItems>

              <!-- Amennyiben a rendszer másképpen nem tudja eldönteni, hogy melyik az aktív kimenő internet kapcsolat,
                  egy próbacsatlakozást hajt végre. Ha a csatlakozás sikeres, a helyi interface-t használja fel az UPnP router konfiguráláshoz.
                  A szolgáltatás nem működik, ha nincs legalább egy sikeresen megnyitott TCP szerver.
              -->
              <add id="ProbeAddressToDetectGatewayNetworkInterface" entryValue="www.ForgeNET.com:80" />

            </PropertyItems>
          </add>

        </PropertyItems>
      </add>

      <!-- Saját context nevem definiálása -->
      <add id="NetworkContext" entryValue="A">
        <PropertyItems>

          <!-- Context-ek szeparálhatóságának beállítása -->
          <add id="Separation" entryValue="false">
            <PropertyItems>

              <!-- WhiteList used when the separation enabled -->
              <add id="WhiteList">
                <PropertyItems>
                </PropertyItems>
              </add>

              <!-- BlackList used when the separation disabled -->
              <add id="BlackList">
                <PropertyItems>
                </PropertyItems>
              </add>
            </PropertyItems>
          </add>

        </PropertyItems>
      </add>

    </CategoryPropertyItems>
  </TerraGrafSection>

  <StorageSection>
    <CategoryPropertyItems>
      <add id="NHibernateProvider">
        <PropertyItems>
          <add id="KnownStorageIdsToReset">
            <PropertyItems>
              <!-- add id="TESTING" /-->
            </PropertyItems>
          </add>
          <add id="NHibernateStorages">
            <PropertyItems>
              <add id="Default">
                <PropertyItems>

                  <add id="DatabaseManager" entryValue="" />

                  <add id="NHibernateSettings">
                    <PropertyItems>
                      <add id="dialect" entryValue="NHibernate.Dialect.MsSql2008Dialect" />
                      <add id="connection.provider" entryValue="NHibernate.Connection.DriverConnectionProvider" />
                      <add id="connection.driver_class" entryValue="NHibernate.Driver.Sql2008ClientDriver" />
                      <add id="connection.connection_string_name" entryValue="EverlightTest1DB" />
                      <!--NHibernateStorageProvider-->
                      <add id="connection.isolation" entryValue="ReadCommitted" />
                      <add id="cache.use_query_cache" entryValue="false" />
                      <add id="cache.use_second_level_cache" entryValue="false" />
                      <add id="adonet.batch_size" entryValue="10" />
                      <add id="show_sql" entryValue="false" />
                      <add id="command_timeout" entryValue="60" />
                      <add id="query.substitutions" entryValue="true 1, false 0, yes 'Y', no 'N'" />
                      <add id="max_fetch_depth" entryValue="3" />
                      <add id="use_reflection_optimizer" entryValue="true" />
                      <!--add id="prepare_sql" entryValue="true" /-->
                    </PropertyItems>
                  </add>

                </PropertyItems>
              </add>
            </PropertyItems>
          </add>
        </PropertyItems>
      </add>
    </CategoryPropertyItems>
  </StorageSection>

  <ThreadPoolSection>
    <ThreadPools>
      <add minThreadNumber="1" maxThreadNumber="100" shutDownIdleThreadTime="120000" maxStackSize="0" setReadOnly="false" />
      <add name="TerraGraf_Network_Send" minThreadNumber="4" maxThreadNumber="200" shutDownIdleThreadTime="120000" maxStackSize="0" setReadOnly="false" />
      <add name="TerraGraf_Network_Connection" minThreadNumber="1" maxThreadNumber="5" shutDownIdleThreadTime="120000" maxStackSize="0" setReadOnly="false" />
      <add name="TerraGraf_Network_BroadcastServer" minThreadNumber="1" maxThreadNumber="5" shutDownIdleThreadTime="120000" maxStackSize="0" setReadOnly="false" />
    </ThreadPools>
  </ThreadPoolSection>

  <log4net debug="true">

    <appender name="EventLogAppender" type="log4net.Appender.EventLogAppender">
      <param name="LogName" value="ForgeTest" />
      <param name="ApplicationName" value="ForgeTest" />
      <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%d %-5p [%t] [%c] - %m%n" />
      </layout>
      <filter type="log4net.Filter.LevelRangeFilter">
        <param name="LevelMin" value="ERROR" />
        <param name="LevelMax" value="FATAL" />
      </filter>
    </appender>

    <appender name="RollingLogFileAppender" type="log4net.Appender.RollingFileAppender">
      <file value="c:\LogFiles\EverlightFirstTest.log" />
      <appendToFile value="false" />
      <rollingStyle value="Size" />
      <maxSizeRollBackups value="5" />
      <maximumFileSize value="100MB" />
      <staticLogFileName value="true" />
      <layout type="log4net.Layout.PatternLayout">
        <conversionPattern value="%d %-5p [%t] [%c] - %m%n" />
      </layout>
    </appender>

    <root>
      <appender-ref ref="EventLogAppender" />
      <appender-ref ref="RollingLogFileAppender" />
      <logger name="NHibernate">
        <level value="ALL" />
      </logger>
      <logger name="NHibernate.SQL">
        <level value="ALL" />
      </logger>
    </root>

    <category name="Forge.Net">
      <priority value="Info" />
    </category>

    <category name="Forge.Threading">
      <priority value="Error" />
    </category>

    <category name="Forge.Testing">
      <priority value="ALL" />
    </category>

    <category name="NHibernate">
      <priority value="Error" />
    </category>

  </log4net>
  
</configuration>